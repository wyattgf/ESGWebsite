{"ast":null,"code":"/* eslint no-prototype-builtins: 0 */\n\n/**\n * jQuery-csv (jQuery Plugin)\n *\n * This document is licensed as free software under the terms of the\n * MIT License: http://www.opensource.org/licenses/mit-license.php\n *\n * Acknowledgements:\n * The original design and influence to implement this library as a jquery\n * plugin is influenced by jquery-json (http://code.google.com/p/jquery-json/).\n * If you're looking to use native JSON.Stringify but want additional backwards\n * compatibility for browsers that don't support it, I highly recommend you\n * check it out.\n *\n * A special thanks goes out to rwk@acm.org for providing a lot of valuable\n * feedback to the project including the core for the new FSM\n * (Finite State Machine) parsers. If you're looking for a stable TSV parser\n * be sure to take a look at jquery-tsv (http://code.google.com/p/jquery-tsv/).\n\n * For legal purposes I'll include the \"NO WARRANTY EXPRESSED OR IMPLIED.\n * USE AT YOUR OWN RISK.\". Which, in 'layman's terms' means, by using this\n * library you are accepting responsibility if it breaks your code.\n *\n * Legal jargon aside, I will do my best to provide a useful and stable core\n * that can effectively be built on.\n *\n * Copyrighted 2012 by Evan Plaice.\n */\nRegExp.escape = function (s) {\n  return s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n};\n\n(function () {\n  'use strict';\n\n  var $; // to keep backwards compatibility\n\n  if (typeof jQuery !== 'undefined' && jQuery) {\n    $ = jQuery;\n  } else {\n    $ = {};\n  }\n  /**\n   * jQuery.csv.defaults\n   * Encapsulates the method paramater defaults for the CSV plugin module.\n   */\n\n\n  $.csv = {\n    defaults: {\n      separator: ',',\n      delimiter: '\"',\n      headers: true\n    },\n    hooks: {\n      castToScalar: function (value, state) {\n        var hasDot = /\\./;\n\n        if (isNaN(value)) {\n          return value;\n        } else {\n          if (hasDot.test(value)) {\n            return parseFloat(value);\n          } else {\n            var integer = parseInt(value);\n\n            if (isNaN(integer)) {\n              return null;\n            } else {\n              return integer;\n            }\n          }\n        }\n      }\n    },\n    parsers: {\n      parse: function (csv, options) {\n        // cache settings\n        var separator = options.separator;\n        var delimiter = options.delimiter; // set initial state if it's missing\n\n        if (!options.state.rowNum) {\n          options.state.rowNum = 1;\n        }\n\n        if (!options.state.colNum) {\n          options.state.colNum = 1;\n        } // clear initial state\n\n\n        var data = [];\n        var entry = [];\n        var state = 0;\n        var value = '';\n        var exit = false;\n\n        function endOfEntry() {\n          // reset the state\n          state = 0;\n          value = ''; // if 'start' hasn't been met, don't output\n\n          if (options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = [];\n            options.state.rowNum++;\n            options.state.colNum = 1;\n            return;\n          }\n\n          if (options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            data.push(entry);\n          } else {\n            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook\n            // false skips the row, configurable through a hook\n\n            if (hookVal !== false) {\n              data.push(hookVal);\n            }\n          } // console.log('entry:' + entry);\n          // cleanup\n\n\n          entry = []; // if 'end' is met, stop parsing\n\n          if (options.end && options.state.rowNum >= options.end) {\n            exit = true;\n          } // update global state\n\n\n          options.state.rowNum++;\n          options.state.colNum = 1;\n        }\n\n        function endOfValue() {\n          if (options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value);\n          } else if (options.headers && options.state.rowNum === 1) {\n            // don't onParseValue object headers\n            entry.push(value);\n          } else {\n            var hook = options.onParseValue(value, options.state); // onParseValue Hook\n            // false skips the row, configurable through a hook\n\n            if (hook !== false) {\n              entry.push(hook);\n            }\n          } // console.log('value:' + value);\n          // reset the state\n\n\n          value = '';\n          state = 0; // update global state\n\n          options.state.colNum++;\n        } // escape regex-specific control chars\n\n\n        var escSeparator = RegExp.escape(separator);\n        var escDelimiter = RegExp.escape(delimiter); // compile the regEx str using the custom delimiter/separator\n\n        var match = /(D|S|\\r\\n|\\n|\\r|[^DS\\r\\n]+)/;\n        var matchSrc = match.source;\n        matchSrc = matchSrc.replace(/S/g, escSeparator);\n        matchSrc = matchSrc.replace(/D/g, escDelimiter);\n        match = new RegExp(matchSrc, 'gm'); // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n\n        csv.replace(match, function (m0) {\n          if (exit) {\n            return;\n          }\n\n          switch (state) {\n            // the start of a value\n            case 0:\n              // null last value\n              if (m0 === separator) {\n                value += '';\n                endOfValue();\n                break;\n              } // opening delimiter\n\n\n              if (m0 === delimiter) {\n                state = 1;\n                break;\n              } // null last value\n\n\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue();\n                endOfEntry();\n                break;\n              } // un-delimited value\n\n\n              value += m0;\n              state = 3;\n              break;\n            // delimited input\n\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                state = 2;\n                break;\n              } // delimited data\n\n\n              value += m0;\n              state = 1;\n              break;\n            // delimiter found in delimited input\n\n            case 2:\n              // escaped delimiter?\n              if (m0 === delimiter) {\n                value += m0;\n                state = 1;\n                break;\n              } // null value\n\n\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              } // end of entry\n\n\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue();\n                endOfEntry();\n                break;\n              } // broken paser?\n\n\n              throw Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n            // un-delimited input\n\n            case 3:\n              // null last value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              } // end of entry\n\n\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue();\n                endOfEntry();\n                break;\n              }\n\n              if (m0 === delimiter) {\n                // non-compliant data\n                throw Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n              } // broken parser?\n\n\n              throw Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n\n            default:\n              // shenanigans\n              throw Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n          } // console.log('val:' + m0 + ' state:' + state);\n\n        }); // submit the last entry\n        // ignore null last line\n\n        if (entry.length !== 0) {\n          endOfValue();\n          endOfEntry();\n        }\n\n        return data;\n      },\n      // a csv-specific line splitter\n      splitLines: function (csv, options) {\n        if (!csv) {\n          return undefined;\n        }\n\n        options = options || {}; // cache settings\n\n        var separator = options.separator || $.csv.defaults.separator;\n        var delimiter = options.delimiter || $.csv.defaults.delimiter; // set initial state if it's missing\n\n        options.state = options.state || {};\n\n        if (!options.state.rowNum) {\n          options.state.rowNum = 1;\n        } // clear initial state\n\n\n        var entries = [];\n        var state = 0;\n        var entry = '';\n        var exit = false;\n\n        function endOfLine() {\n          // reset the state\n          state = 0; // if 'start' hasn't been met, don't output\n\n          if (options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = '';\n            options.state.rowNum++;\n            return;\n          }\n\n          if (options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            entries.push(entry);\n          } else {\n            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook\n            // false skips the row, configurable through a hook\n\n            if (hookVal !== false) {\n              entries.push(hookVal);\n            }\n          } // cleanup\n\n\n          entry = ''; // if 'end' is met, stop parsing\n\n          if (options.end && options.state.rowNum >= options.end) {\n            exit = true;\n          } // update global state\n\n\n          options.state.rowNum++;\n        } // escape regex-specific control chars\n\n\n        var escSeparator = RegExp.escape(separator);\n        var escDelimiter = RegExp.escape(delimiter); // compile the regEx str using the custom delimiter/separator\n\n        var match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/;\n        var matchSrc = match.source;\n        matchSrc = matchSrc.replace(/S/g, escSeparator);\n        matchSrc = matchSrc.replace(/D/g, escDelimiter);\n        match = new RegExp(matchSrc, 'gm'); // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n\n        csv.replace(match, function (m0) {\n          if (exit) {\n            return;\n          }\n\n          switch (state) {\n            // the start of a value/entry\n            case 0:\n              // null value\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              } // opening delimiter\n\n\n              if (m0 === delimiter) {\n                entry += m0;\n                state = 1;\n                break;\n              } // end of line\n\n\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              } // phantom carriage return\n\n\n              if (/^\\r$/.test(m0)) {\n                break;\n              } // un-delimit value\n\n\n              entry += m0;\n              state = 3;\n              break;\n            // delimited input\n\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                entry += m0;\n                state = 2;\n                break;\n              } // delimited data\n\n\n              entry += m0;\n              state = 1;\n              break;\n            // delimiter found in delimited input\n\n            case 2:\n              // escaped delimiter?\n              var prevChar = entry.substr(entry.length - 1);\n\n              if (m0 === delimiter && prevChar === delimiter) {\n                entry += m0;\n                state = 1;\n                break;\n              } // end of value\n\n\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              } // end of line\n\n\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              } // phantom carriage return\n\n\n              if (m0 === '\\r') {\n                break;\n              } // broken paser?\n\n\n              throw Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');\n            // un-delimited input\n\n            case 3:\n              // null value\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              } // end of line\n\n\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              } // phantom carriage return\n\n\n              if (m0 === '\\r') {\n                break;\n              } // non-compliant data\n\n\n              if (m0 === delimiter) {\n                throw Error('CSVDataError: Illegal quote [Row:' + options.state.rowNum + ']');\n              } // broken parser?\n\n\n              throw Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');\n\n            default:\n              // shenanigans\n              throw Error('CSVDataError: Unknown state [Row:' + options.state.rowNum + ']');\n          } // console.log('val:' + m0 + ' state:' + state);\n\n        }); // submit the last entry\n        // ignore null last line\n\n        if (entry !== '') {\n          endOfLine();\n        }\n\n        return entries;\n      },\n      // a csv entry parser\n      parseEntry: function (csv, options) {\n        // cache settings\n        var separator = options.separator;\n        var delimiter = options.delimiter; // set initial state if it's missing\n\n        if (!options.state.rowNum) {\n          options.state.rowNum = 1;\n        }\n\n        if (!options.state.colNum) {\n          options.state.colNum = 1;\n        } // clear initial state\n\n\n        var entry = [];\n        var state = 0;\n        var value = '';\n\n        function endOfValue() {\n          if (options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value);\n          } else {\n            var hook = options.onParseValue(value, options.state); // onParseValue Hook\n            // false skips the value, configurable through a hook\n\n            if (hook !== false) {\n              entry.push(hook);\n            }\n          } // reset the state\n\n\n          value = '';\n          state = 0; // update global state\n\n          options.state.colNum++;\n        } // checked for a cached regEx first\n\n\n        if (!options.match) {\n          // escape regex-specific control chars\n          var escSeparator = RegExp.escape(separator);\n          var escDelimiter = RegExp.escape(delimiter); // compile the regEx str using the custom delimiter/separator\n\n          var match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/;\n          var matchSrc = match.source;\n          matchSrc = matchSrc.replace(/S/g, escSeparator);\n          matchSrc = matchSrc.replace(/D/g, escDelimiter);\n          options.match = new RegExp(matchSrc, 'gm');\n        } // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n\n\n        csv.replace(options.match, function (m0) {\n          switch (state) {\n            // the start of a value\n            case 0:\n              // null last value\n              if (m0 === separator) {\n                value += '';\n                endOfValue();\n                break;\n              } // opening delimiter\n\n\n              if (m0 === delimiter) {\n                state = 1;\n                break;\n              } // skip un-delimited new-lines\n\n\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              } // un-delimited value\n\n\n              value += m0;\n              state = 3;\n              break;\n            // delimited input\n\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                state = 2;\n                break;\n              } // delimited data\n\n\n              value += m0;\n              state = 1;\n              break;\n            // delimiter found in delimited input\n\n            case 2:\n              // escaped delimiter?\n              if (m0 === delimiter) {\n                value += m0;\n                state = 1;\n                break;\n              } // null value\n\n\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              } // skip un-delimited new-lines\n\n\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              } // broken paser?\n\n\n              throw Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n            // un-delimited input\n\n            case 3:\n              // null last value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              } // skip un-delimited new-lines\n\n\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              } // non-compliant data\n\n\n              if (m0 === delimiter) {\n                throw Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n              } // broken parser?\n\n\n              throw Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n\n            default:\n              // shenanigans\n              throw Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n          } // console.log('val:' + m0 + ' state:' + state);\n\n        }); // submit the last value\n\n        endOfValue();\n        return entry;\n      }\n    },\n    helpers: {\n      /**\n       * $.csv.helpers.collectPropertyNames(objectsArray)\n       * Collects all unique property names from all passed objects.\n       *\n       * @param {Array} objects Objects to collect properties from.\n       *\n       * Returns an array of property names (array will be empty,\n       * if objects have no own properties).\n       */\n      collectPropertyNames: function (objects) {\n        var o = [];\n        var propName = [];\n        var props = [];\n\n        for (o in objects) {\n          for (propName in objects[o]) {\n            if (objects[o].hasOwnProperty(propName) && props.indexOf(propName) < 0 && typeof objects[o][propName] !== 'function') {\n              props.push(propName);\n            }\n          }\n        }\n\n        return props;\n      }\n    },\n\n    /**\n     * $.csv.toArray(csv)\n     * Converts a CSV entry string to a javascript array.\n     *\n     * @param {Array} csv The string containing the CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method deals with simple CSV strings only. It's useful if you only\n     * need to parse a single entry. If you need to parse more than one line,\n     * use $.csv2Array instead.\n     */\n    toArray: function (csv, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof options === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\n        }\n\n        callback = options;\n        options = {};\n      }\n\n      options = options !== undefined ? options : {};\n      var config = {};\n      config.callback = callback !== undefined && typeof callback === 'function' ? callback : false;\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      var state = options.state !== undefined ? options.state : {}; // setup\n\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        state: state\n      };\n      var entry = $.csv.parsers.parseEntry(csv, options); // push the value to a callback if one is defined\n\n      if (!config.callback) {\n        return entry;\n      } else {\n        config.callback('', entry);\n      }\n    },\n\n    /**\n     * $.csv.toArrays(csv)\n     * Converts a CSV string to a javascript array.\n     *\n     * @param {String} csv The string containing the raw CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method deals with multi-line CSV. The breakdown is simple. The first\n     * dimension of the array represents the line (or entry/row) while the second\n     * dimension contains the values (or values/columns).\n     */\n    toArrays: function (csv, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof options === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\n        }\n\n        callback = options;\n        options = {};\n      }\n\n      options = options !== undefined ? options : {};\n      var config = {};\n      config.callback = callback !== undefined && typeof callback === 'function' ? callback : false;\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter; // setup\n\n      var data = [];\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onPreParse: options.onPreParse,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        onPostParse: options.onPostParse,\n        start: options.start,\n        end: options.end,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        }\n      }; // onPreParse hook\n\n      if (options.onPreParse !== undefined) {\n        csv = options.onPreParse(csv, options.state);\n      } // parse the data\n\n\n      data = $.csv.parsers.parse(csv, options); // onPostParse hook\n\n      if (options.onPostParse !== undefined) {\n        data = options.onPostParse(data, options.state);\n      } // push the value to a callback if one is defined\n\n\n      if (!config.callback) {\n        return data;\n      } else {\n        config.callback('', data);\n      }\n    },\n\n    /**\n     * $.csv.toObjects(csv)\n     * Converts a CSV string to a javascript object.\n     * @param {String} csv The string containing the raw CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     * @param {Boolean} [headers] Indicates whether the data contains a header line. Defaults to true.\n     *\n     * This method deals with multi-line CSV strings. Where the headers line is\n     * used as the key for each value per entry.\n     */\n    toObjects: function (csv, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof options === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\n        }\n\n        callback = options;\n        options = {};\n      }\n\n      options = options !== undefined ? options : {};\n      var config = {};\n      config.callback = callback !== undefined && typeof callback === 'function' ? callback : false;\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers;\n      options.start = 'start' in options ? options.start : 1; // account for headers\n\n      if (config.headers) {\n        options.start++;\n      }\n\n      if (options.end && config.headers) {\n        options.end++;\n      } // setup\n\n\n      var lines = [];\n      var data = [];\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onPreParse: options.onPreParse,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        onPostParse: options.onPostParse,\n        start: options.start,\n        end: options.end,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        },\n        match: false,\n        transform: options.transform\n      }; // fetch the headers\n\n      var headerOptions = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        start: 1,\n        end: 1,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        },\n        headers: true\n      }; // onPreParse hook\n\n      if (options.onPreParse !== undefined) {\n        csv = options.onPreParse(csv, options.state);\n      } // parse the csv\n\n\n      var headerLine = $.csv.parsers.splitLines(csv, headerOptions);\n      var headers = $.csv.toArray(headerLine[0], headerOptions); // fetch the data\n\n      lines = $.csv.parsers.splitLines(csv, options); // reset the state for re-use\n\n      options.state.colNum = 1;\n\n      if (headers) {\n        options.state.rowNum = 2;\n      } else {\n        options.state.rowNum = 1;\n      } // convert data to objects\n\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        var entry = $.csv.toArray(lines[i], options);\n        var object = {};\n\n        for (var j = 0; j < headers.length; j++) {\n          object[headers[j]] = entry[j];\n        }\n\n        if (options.transform !== undefined) {\n          data.push(options.transform.call(undefined, object));\n        } else {\n          data.push(object);\n        } // update row state\n\n\n        options.state.rowNum++;\n      } // onPostParse hook\n\n\n      if (options.onPostParse !== undefined) {\n        data = options.onPostParse(data, options.state);\n      } // push the value to a callback if one is defined\n\n\n      if (!config.callback) {\n        return data;\n      } else {\n        config.callback('', data);\n      }\n    },\n\n    /**\n    * $.csv.fromArrays(arrays)\n    * Converts a javascript array to a CSV String.\n    *\n    * @param {Array} arrays An array containing an array of CSV entries.\n    * @param {Object} [options] An object containing user-defined options.\n    * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n    * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n    *\n    * This method generates a CSV file from an array of arrays (representing entries).\n    */\n    fromArrays: function (arrays, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof options === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\n        }\n\n        callback = options;\n        options = {};\n      }\n\n      options = options !== undefined ? options : {};\n      var config = {};\n      config.callback = callback !== undefined && typeof callback === 'function' ? callback : false;\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      var output = '';\n      var line;\n      var lineValues;\n      var i;\n      var j;\n\n      for (i = 0; i < arrays.length; i++) {\n        line = arrays[i];\n        lineValues = [];\n\n        for (j = 0; j < line.length; j++) {\n          var strValue = line[j] === undefined || line[j] === null ? '' : line[j].toString();\n\n          if (strValue.indexOf(config.delimiter) > -1) {\n            strValue = strValue.replace(new RegExp(config.delimiter, 'g'), config.delimiter + config.delimiter);\n          }\n\n          var escMatcher = '\\n|\\r|S|D';\n          escMatcher = escMatcher.replace('S', config.separator);\n          escMatcher = escMatcher.replace('D', config.delimiter);\n\n          if (strValue.search(escMatcher) > -1) {\n            strValue = config.delimiter + strValue + config.delimiter;\n          }\n\n          lineValues.push(strValue);\n        }\n\n        output += lineValues.join(config.separator) + '\\n';\n      } // push the value to a callback if one is defined\n\n\n      if (!config.callback) {\n        return output;\n      } else {\n        config.callback('', output);\n      }\n    },\n\n    /**\n     * $.csv.fromObjects(objects)\n     * Converts a javascript dictionary to a CSV string.\n     *\n     * @param {Object} objects An array of objects containing the data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     * @param {Character} [sortOrder] Sort order of columns (named after\n     *   object properties). Use 'alpha' for alphabetic. Default is 'declare',\n     *   which means, that properties will _probably_ appear in order they were\n     *   declared for the object. But without any guarantee.\n     * @param {Character or Array} [manualOrder] Manually order columns. May be\n     * a strin in a same csv format as an output or an array of header names\n     * (array items won't be parsed). All the properties, not present in\n     * `manualOrder` will be appended to the end in accordance with `sortOrder`\n     * option. So the `manualOrder` always takes preference, if present.\n     *\n     * This method generates a CSV file from an array of objects (name:value pairs).\n     * It starts by detecting the headers and adding them as the first line of\n     * the CSV file, followed by a structured dump of the data.\n     */\n    fromObjects: function (objects, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof options === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\n        }\n\n        callback = options;\n        options = {};\n      }\n\n      options = options !== undefined ? options : {};\n      var config = {};\n      config.callback = callback !== undefined && typeof callback === 'function' ? callback : false;\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers;\n      config.sortOrder = 'sortOrder' in options ? options.sortOrder : 'declare';\n      config.manualOrder = 'manualOrder' in options ? options.manualOrder : [];\n      config.transform = options.transform;\n\n      if (typeof config.manualOrder === 'string') {\n        config.manualOrder = $.csv.toArray(config.manualOrder, config);\n      }\n\n      if (config.transform !== undefined) {\n        var origObjects = objects;\n        objects = [];\n        var i;\n\n        for (i = 0; i < origObjects.length; i++) {\n          objects.push(config.transform.call(undefined, origObjects[i]));\n        }\n      }\n\n      var props = $.csv.helpers.collectPropertyNames(objects);\n\n      if (config.sortOrder === 'alpha') {\n        props.sort();\n      } // else {} - nothing to do for 'declare' order\n\n\n      if (config.manualOrder.length > 0) {\n        var propsManual = [].concat(config.manualOrder);\n        var p;\n\n        for (p = 0; p < props.length; p++) {\n          if (propsManual.indexOf(props[p]) < 0) {\n            propsManual.push(props[p]);\n          }\n        }\n\n        props = propsManual;\n      }\n\n      var o;\n      var line;\n      var output = [];\n      var propName;\n\n      if (config.headers) {\n        output.push(props);\n      }\n\n      for (o = 0; o < objects.length; o++) {\n        line = [];\n\n        for (p = 0; p < props.length; p++) {\n          propName = props[p];\n\n          if (propName in objects[o] && typeof objects[o][propName] !== 'function') {\n            line.push(objects[o][propName]);\n          } else {\n            line.push('');\n          }\n        }\n\n        output.push(line);\n      } // push the value to a callback if one is defined\n\n\n      return $.csv.fromArrays(output, options, config.callback);\n    }\n  }; // Maintenance code to maintain backward-compatibility\n  // Will be removed in release 1.0\n\n  $.csvEntry2Array = $.csv.toArray;\n  $.csv2Array = $.csv.toArrays;\n  $.csv2Dictionary = $.csv.toObjects; // CommonJS module is defined\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = $.csv;\n  }\n}).call(this);","map":{"version":3,"sources":["/Users/wyattfocht/Documents/Website Projects/ESGWebsite/esgwebsite/node_modules/jquery-csv/src/jquery.csv.js"],"names":["RegExp","escape","s","replace","$","jQuery","csv","defaults","separator","delimiter","headers","hooks","castToScalar","value","state","hasDot","isNaN","test","parseFloat","integer","parseInt","parsers","parse","options","rowNum","colNum","data","entry","exit","endOfEntry","start","onParseEntry","undefined","push","hookVal","end","endOfValue","onParseValue","hook","escSeparator","escDelimiter","match","matchSrc","source","m0","Error","length","splitLines","entries","endOfLine","prevChar","substr","parseEntry","helpers","collectPropertyNames","objects","o","propName","props","hasOwnProperty","indexOf","toArray","callback","console","error","config","toArrays","onPreParse","onPostParse","toObjects","lines","transform","headerOptions","headerLine","i","len","object","j","call","fromArrays","arrays","output","line","lineValues","strValue","toString","escMatcher","search","join","fromObjects","sortOrder","manualOrder","origObjects","sort","propsManual","concat","p","csvEntry2Array","csv2Array","csv2Dictionary","module","exports"],"mappings":"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","sourcesContent":["/* eslint no-prototype-builtins: 0 */\n/**\n * jQuery-csv (jQuery Plugin)\n *\n * This document is licensed as free software under the terms of the\n * MIT License: http://www.opensource.org/licenses/mit-license.php\n *\n * Acknowledgements:\n * The original design and influence to implement this library as a jquery\n * plugin is influenced by jquery-json (http://code.google.com/p/jquery-json/).\n * If you're looking to use native JSON.Stringify but want additional backwards\n * compatibility for browsers that don't support it, I highly recommend you\n * check it out.\n *\n * A special thanks goes out to rwk@acm.org for providing a lot of valuable\n * feedback to the project including the core for the new FSM\n * (Finite State Machine) parsers. If you're looking for a stable TSV parser\n * be sure to take a look at jquery-tsv (http://code.google.com/p/jquery-tsv/).\n\n * For legal purposes I'll include the \"NO WARRANTY EXPRESSED OR IMPLIED.\n * USE AT YOUR OWN RISK.\". Which, in 'layman's terms' means, by using this\n * library you are accepting responsibility if it breaks your code.\n *\n * Legal jargon aside, I will do my best to provide a useful and stable core\n * that can effectively be built on.\n *\n * Copyrighted 2012 by Evan Plaice.\n */\n\nRegExp.escape = function (s) {\n  return s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n};\n\n(function () {\n  'use strict';\n\n  var $;\n\n  // to keep backwards compatibility\n  if (typeof jQuery !== 'undefined' && jQuery) {\n    $ = jQuery;\n  } else {\n    $ = {};\n  }\n\n  /**\n   * jQuery.csv.defaults\n   * Encapsulates the method paramater defaults for the CSV plugin module.\n   */\n\n  $.csv = {\n    defaults: {\n      separator: ',',\n      delimiter: '\"',\n      headers: true\n    },\n\n    hooks: {\n      castToScalar: function (value, state) {\n        var hasDot = /\\./;\n        if (isNaN(value)) {\n          return value;\n        } else {\n          if (hasDot.test(value)) {\n            return parseFloat(value);\n          } else {\n            var integer = parseInt(value);\n            if (isNaN(integer)) {\n              return null;\n            } else {\n              return integer;\n            }\n          }\n        }\n      }\n    },\n\n    parsers: {\n      parse: function (csv, options) {\n        // cache settings\n        var separator = options.separator;\n        var delimiter = options.delimiter;\n\n        // set initial state if it's missing\n        if (!options.state.rowNum) {\n          options.state.rowNum = 1;\n        }\n        if (!options.state.colNum) {\n          options.state.colNum = 1;\n        }\n\n        // clear initial state\n        var data = [];\n        var entry = [];\n        var state = 0;\n        var value = '';\n        var exit = false;\n\n        function endOfEntry () {\n          // reset the state\n          state = 0;\n          value = '';\n\n          // if 'start' hasn't been met, don't output\n          if (options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = [];\n            options.state.rowNum++;\n            options.state.colNum = 1;\n            return;\n          }\n\n          if (options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            data.push(entry);\n          } else {\n            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook\n            // false skips the row, configurable through a hook\n            if (hookVal !== false) {\n              data.push(hookVal);\n            }\n          }\n          // console.log('entry:' + entry);\n\n          // cleanup\n          entry = [];\n\n          // if 'end' is met, stop parsing\n          if (options.end && options.state.rowNum >= options.end) {\n            exit = true;\n          }\n\n          // update global state\n          options.state.rowNum++;\n          options.state.colNum = 1;\n        }\n\n        function endOfValue () {\n          if (options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value);\n          } else if (options.headers && options.state.rowNum === 1) {\n            // don't onParseValue object headers\n            entry.push(value);\n          } else {\n            var hook = options.onParseValue(value, options.state); // onParseValue Hook\n            // false skips the row, configurable through a hook\n            if (hook !== false) {\n              entry.push(hook);\n            }\n          }\n          // console.log('value:' + value);\n          // reset the state\n          value = '';\n          state = 0;\n          // update global state\n          options.state.colNum++;\n        }\n\n        // escape regex-specific control chars\n        var escSeparator = RegExp.escape(separator);\n        var escDelimiter = RegExp.escape(delimiter);\n\n        // compile the regEx str using the custom delimiter/separator\n        var match = /(D|S|\\r\\n|\\n|\\r|[^DS\\r\\n]+)/;\n        var matchSrc = match.source;\n        matchSrc = matchSrc.replace(/S/g, escSeparator);\n        matchSrc = matchSrc.replace(/D/g, escDelimiter);\n        match = new RegExp(matchSrc, 'gm');\n\n        // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n        csv.replace(match, function (m0) {\n          if (exit) {\n            return;\n          }\n          switch (state) {\n            // the start of a value\n            case 0:\n              // null last value\n              if (m0 === separator) {\n                value += '';\n                endOfValue();\n                break;\n              }\n              // opening delimiter\n              if (m0 === delimiter) {\n                state = 1;\n                break;\n              }\n              // null last value\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue();\n                endOfEntry();\n                break;\n              }\n              // un-delimited value\n              value += m0;\n              state = 3;\n              break;\n\n            // delimited input\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                state = 2;\n                break;\n              }\n              // delimited data\n              value += m0;\n              state = 1;\n              break;\n\n            // delimiter found in delimited input\n            case 2:\n              // escaped delimiter?\n              if (m0 === delimiter) {\n                value += m0;\n                state = 1;\n                break;\n              }\n              // null value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              }\n              // end of entry\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue();\n                endOfEntry();\n                break;\n              }\n              // broken paser?\n              throw Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n\n            // un-delimited input\n            case 3:\n              // null last value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              }\n              // end of entry\n              if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                endOfValue();\n                endOfEntry();\n                break;\n              }\n              if (m0 === delimiter) {\n              // non-compliant data\n                throw Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n              }\n              // broken parser?\n              throw Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n            default:\n              // shenanigans\n              throw Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n          }\n          // console.log('val:' + m0 + ' state:' + state);\n        });\n\n        // submit the last entry\n        // ignore null last line\n        if (entry.length !== 0) {\n          endOfValue();\n          endOfEntry();\n        }\n\n        return data;\n      },\n\n      // a csv-specific line splitter\n      splitLines: function (csv, options) {\n        if (!csv) {\n          return undefined;\n        }\n\n        options = options || {};\n\n        // cache settings\n        var separator = options.separator || $.csv.defaults.separator;\n        var delimiter = options.delimiter || $.csv.defaults.delimiter;\n\n        // set initial state if it's missing\n        options.state = options.state || {};\n        if (!options.state.rowNum) {\n          options.state.rowNum = 1;\n        }\n\n        // clear initial state\n        var entries = [];\n        var state = 0;\n        var entry = '';\n        var exit = false;\n\n        function endOfLine () {\n          // reset the state\n          state = 0;\n\n          // if 'start' hasn't been met, don't output\n          if (options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = '';\n            options.state.rowNum++;\n            return;\n          }\n\n          if (options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            entries.push(entry);\n          } else {\n            var hookVal = options.onParseEntry(entry, options.state); // onParseEntry Hook\n            // false skips the row, configurable through a hook\n            if (hookVal !== false) {\n              entries.push(hookVal);\n            }\n          }\n\n          // cleanup\n          entry = '';\n\n          // if 'end' is met, stop parsing\n          if (options.end && options.state.rowNum >= options.end) {\n            exit = true;\n          }\n\n          // update global state\n          options.state.rowNum++;\n        }\n\n        // escape regex-specific control chars\n        var escSeparator = RegExp.escape(separator);\n        var escDelimiter = RegExp.escape(delimiter);\n\n        // compile the regEx str using the custom delimiter/separator\n        var match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/;\n        var matchSrc = match.source;\n        matchSrc = matchSrc.replace(/S/g, escSeparator);\n        matchSrc = matchSrc.replace(/D/g, escDelimiter);\n        match = new RegExp(matchSrc, 'gm');\n\n        // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n        csv.replace(match, function (m0) {\n          if (exit) {\n            return;\n          }\n          switch (state) {\n            // the start of a value/entry\n            case 0:\n              // null value\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              }\n              // opening delimiter\n              if (m0 === delimiter) {\n                entry += m0;\n                state = 1;\n                break;\n              }\n              // end of line\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              }\n              // phantom carriage return\n              if (/^\\r$/.test(m0)) {\n                break;\n              }\n              // un-delimit value\n              entry += m0;\n              state = 3;\n              break;\n\n            // delimited input\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                entry += m0;\n                state = 2;\n                break;\n              }\n              // delimited data\n              entry += m0;\n              state = 1;\n              break;\n\n            // delimiter found in delimited input\n            case 2:\n              // escaped delimiter?\n              var prevChar = entry.substr(entry.length - 1);\n              if (m0 === delimiter && prevChar === delimiter) {\n                entry += m0;\n                state = 1;\n                break;\n              }\n              // end of value\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              }\n              // end of line\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              }\n              // phantom carriage return\n              if (m0 === '\\r') {\n                break;\n              }\n              // broken paser?\n              throw Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');\n\n            // un-delimited input\n            case 3:\n              // null value\n              if (m0 === separator) {\n                entry += m0;\n                state = 0;\n                break;\n              }\n              // end of line\n              if (m0 === '\\n') {\n                endOfLine();\n                break;\n              }\n              // phantom carriage return\n              if (m0 === '\\r') {\n                break;\n              }\n              // non-compliant data\n              if (m0 === delimiter) {\n                throw Error('CSVDataError: Illegal quote [Row:' + options.state.rowNum + ']');\n              }\n              // broken parser?\n              throw Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']');\n            default:\n              // shenanigans\n              throw Error('CSVDataError: Unknown state [Row:' + options.state.rowNum + ']');\n          }\n          // console.log('val:' + m0 + ' state:' + state);\n        });\n\n        // submit the last entry\n        // ignore null last line\n        if (entry !== '') {\n          endOfLine();\n        }\n\n        return entries;\n      },\n\n      // a csv entry parser\n      parseEntry: function (csv, options) {\n        // cache settings\n        var separator = options.separator;\n        var delimiter = options.delimiter;\n\n        // set initial state if it's missing\n        if (!options.state.rowNum) {\n          options.state.rowNum = 1;\n        }\n        if (!options.state.colNum) {\n          options.state.colNum = 1;\n        }\n\n        // clear initial state\n        var entry = [];\n        var state = 0;\n        var value = '';\n\n        function endOfValue () {\n          if (options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value);\n          } else {\n            var hook = options.onParseValue(value, options.state); // onParseValue Hook\n            // false skips the value, configurable through a hook\n            if (hook !== false) {\n              entry.push(hook);\n            }\n          }\n          // reset the state\n          value = '';\n          state = 0;\n          // update global state\n          options.state.colNum++;\n        }\n\n        // checked for a cached regEx first\n        if (!options.match) {\n          // escape regex-specific control chars\n          var escSeparator = RegExp.escape(separator);\n          var escDelimiter = RegExp.escape(delimiter);\n\n          // compile the regEx str using the custom delimiter/separator\n          var match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/;\n          var matchSrc = match.source;\n          matchSrc = matchSrc.replace(/S/g, escSeparator);\n          matchSrc = matchSrc.replace(/D/g, escDelimiter);\n          options.match = new RegExp(matchSrc, 'gm');\n        }\n\n        // put on your fancy pants...\n        // process control chars individually, use look-ahead on non-control chars\n        csv.replace(options.match, function (m0) {\n          switch (state) {\n            // the start of a value\n            case 0:\n              // null last value\n              if (m0 === separator) {\n                value += '';\n                endOfValue();\n                break;\n              }\n              // opening delimiter\n              if (m0 === delimiter) {\n                state = 1;\n                break;\n              }\n              // skip un-delimited new-lines\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              }\n              // un-delimited value\n              value += m0;\n              state = 3;\n              break;\n\n            // delimited input\n            case 1:\n              // second delimiter? check further\n              if (m0 === delimiter) {\n                state = 2;\n                break;\n              }\n              // delimited data\n              value += m0;\n              state = 1;\n              break;\n\n            // delimiter found in delimited input\n            case 2:\n              // escaped delimiter?\n              if (m0 === delimiter) {\n                value += m0;\n                state = 1;\n                break;\n              }\n              // null value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              }\n              // skip un-delimited new-lines\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              }\n              // broken paser?\n              throw Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n\n            // un-delimited input\n            case 3:\n              // null last value\n              if (m0 === separator) {\n                endOfValue();\n                break;\n              }\n              // skip un-delimited new-lines\n              if (m0 === '\\n' || m0 === '\\r') {\n                break;\n              }\n              // non-compliant data\n              if (m0 === delimiter) {\n                throw Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n              }\n              // broken parser?\n              throw Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n            default:\n              // shenanigans\n              throw Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']');\n          }\n          // console.log('val:' + m0 + ' state:' + state);\n        });\n\n        // submit the last value\n        endOfValue();\n\n        return entry;\n      }\n    },\n\n    helpers: {\n\n      /**\n       * $.csv.helpers.collectPropertyNames(objectsArray)\n       * Collects all unique property names from all passed objects.\n       *\n       * @param {Array} objects Objects to collect properties from.\n       *\n       * Returns an array of property names (array will be empty,\n       * if objects have no own properties).\n       */\n      collectPropertyNames: function (objects) {\n        var o = [];\n        var propName = [];\n        var props = [];\n        for (o in objects) {\n          for (propName in objects[o]) {\n            if ((objects[o].hasOwnProperty(propName)) &&\n                (props.indexOf(propName) < 0) &&\n                (typeof objects[o][propName] !== 'function')) {\n              props.push(propName);\n            }\n          }\n        }\n        return props;\n      }\n    },\n\n    /**\n     * $.csv.toArray(csv)\n     * Converts a CSV entry string to a javascript array.\n     *\n     * @param {Array} csv The string containing the CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method deals with simple CSV strings only. It's useful if you only\n     * need to parse a single entry. If you need to parse more than one line,\n     * use $.csv2Array instead.\n     */\n    toArray: function (csv, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\n        }\n        callback = options;\n        options = {};\n      }\n\n      options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      var state = (options.state !== undefined ? options.state : {});\n\n      // setup\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        state: state\n      };\n\n      var entry = $.csv.parsers.parseEntry(csv, options);\n\n      // push the value to a callback if one is defined\n      if (!config.callback) {\n        return entry;\n      } else {\n        config.callback('', entry);\n      }\n    },\n\n    /**\n     * $.csv.toArrays(csv)\n     * Converts a CSV string to a javascript array.\n     *\n     * @param {String} csv The string containing the raw CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     *\n     * This method deals with multi-line CSV. The breakdown is simple. The first\n     * dimension of the array represents the line (or entry/row) while the second\n     * dimension contains the values (or values/columns).\n     */\n    toArrays: function (csv, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\n        }\n        callback = options;\n        options = {};\n      }\n\n      options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n\n      // setup\n      var data = [];\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onPreParse: options.onPreParse,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        onPostParse: options.onPostParse,\n        start: options.start,\n        end: options.end,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        }\n      };\n\n      // onPreParse hook\n      if (options.onPreParse !== undefined) {\n        csv = options.onPreParse(csv, options.state);\n      }\n\n      // parse the data\n      data = $.csv.parsers.parse(csv, options);\n\n      // onPostParse hook\n      if (options.onPostParse !== undefined) {\n        data = options.onPostParse(data, options.state);\n      }\n\n      // push the value to a callback if one is defined\n      if (!config.callback) {\n        return data;\n      } else {\n        config.callback('', data);\n      }\n    },\n\n    /**\n     * $.csv.toObjects(csv)\n     * Converts a CSV string to a javascript object.\n     * @param {String} csv The string containing the raw CSV data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     * @param {Boolean} [headers] Indicates whether the data contains a header line. Defaults to true.\n     *\n     * This method deals with multi-line CSV strings. Where the headers line is\n     * used as the key for each value per entry.\n     */\n    toObjects: function (csv, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\n        }\n        callback = options;\n        options = {};\n      }\n\n      options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers;\n      options.start = 'start' in options ? options.start : 1;\n\n      // account for headers\n      if (config.headers) {\n        options.start++;\n      }\n      if (options.end && config.headers) {\n        options.end++;\n      }\n\n      // setup\n      var lines = [];\n      var data = [];\n\n      options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onPreParse: options.onPreParse,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        onPostParse: options.onPostParse,\n        start: options.start,\n        end: options.end,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        },\n        match: false,\n        transform: options.transform\n      };\n\n      // fetch the headers\n      var headerOptions = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        start: 1,\n        end: 1,\n        state: {\n          rowNum: 1,\n          colNum: 1\n        },\n        headers: true\n      };\n\n      // onPreParse hook\n      if (options.onPreParse !== undefined) {\n        csv = options.onPreParse(csv, options.state);\n      }\n\n      // parse the csv\n      var headerLine = $.csv.parsers.splitLines(csv, headerOptions);\n      var headers = $.csv.toArray(headerLine[0], headerOptions);\n\n      // fetch the data\n      lines = $.csv.parsers.splitLines(csv, options);\n\n      // reset the state for re-use\n      options.state.colNum = 1;\n      if (headers) {\n        options.state.rowNum = 2;\n      } else {\n        options.state.rowNum = 1;\n      }\n\n      // convert data to objects\n      for (var i = 0, len = lines.length; i < len; i++) {\n        var entry = $.csv.toArray(lines[i], options);\n        var object = {};\n        for (var j = 0; j < headers.length; j++) {\n          object[headers[j]] = entry[j];\n        }\n        if (options.transform !== undefined) {\n          data.push(options.transform.call(undefined, object));\n        } else {\n          data.push(object);\n        }\n\n        // update row state\n        options.state.rowNum++;\n      }\n\n      // onPostParse hook\n      if (options.onPostParse !== undefined) {\n        data = options.onPostParse(data, options.state);\n      }\n\n      // push the value to a callback if one is defined\n      if (!config.callback) {\n        return data;\n      } else {\n        config.callback('', data);\n      }\n    },\n\n    /**\n    * $.csv.fromArrays(arrays)\n    * Converts a javascript array to a CSV String.\n    *\n    * @param {Array} arrays An array containing an array of CSV entries.\n    * @param {Object} [options] An object containing user-defined options.\n    * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n    * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n    *\n    * This method generates a CSV file from an array of arrays (representing entries).\n    */\n    fromArrays: function (arrays, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\n        }\n        callback = options;\n        options = {};\n      }\n\n      options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n\n      var output = '';\n      var line;\n      var lineValues;\n      var i;\n      var j;\n\n      for (i = 0; i < arrays.length; i++) {\n        line = arrays[i];\n        lineValues = [];\n        for (j = 0; j < line.length; j++) {\n          var strValue = (line[j] === undefined || line[j] === null) ? '' : line[j].toString();\n          if (strValue.indexOf(config.delimiter) > -1) {\n            strValue = strValue.replace(new RegExp(config.delimiter, 'g'), config.delimiter + config.delimiter);\n          }\n\n          var escMatcher = '\\n|\\r|S|D';\n          escMatcher = escMatcher.replace('S', config.separator);\n          escMatcher = escMatcher.replace('D', config.delimiter);\n\n          if (strValue.search(escMatcher) > -1) {\n            strValue = config.delimiter + strValue + config.delimiter;\n          }\n          lineValues.push(strValue);\n        }\n        output += lineValues.join(config.separator) + '\\n';\n      }\n\n      // push the value to a callback if one is defined\n      if (!config.callback) {\n        return output;\n      } else {\n        config.callback('', output);\n      }\n    },\n\n    /**\n     * $.csv.fromObjects(objects)\n     * Converts a javascript dictionary to a CSV string.\n     *\n     * @param {Object} objects An array of objects containing the data.\n     * @param {Object} [options] An object containing user-defined options.\n     * @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n     * @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n     * @param {Character} [sortOrder] Sort order of columns (named after\n     *   object properties). Use 'alpha' for alphabetic. Default is 'declare',\n     *   which means, that properties will _probably_ appear in order they were\n     *   declared for the object. But without any guarantee.\n     * @param {Character or Array} [manualOrder] Manually order columns. May be\n     * a strin in a same csv format as an output or an array of header names\n     * (array items won't be parsed). All the properties, not present in\n     * `manualOrder` will be appended to the end in accordance with `sortOrder`\n     * option. So the `manualOrder` always takes preference, if present.\n     *\n     * This method generates a CSV file from an array of objects (name:value pairs).\n     * It starts by detecting the headers and adding them as the first line of\n     * the CSV file, followed by a structured dump of the data.\n     */\n    fromObjects: function (objects, options, callback) {\n      // if callback was passed to options swap callback with options\n      if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n          return console.error('You cannot 3 arguments with the 2nd argument being a function');\n        }\n        callback = options;\n        options = {};\n      }\n\n      options = (options !== undefined ? options : {});\n      var config = {};\n      config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false);\n      config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator;\n      config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter;\n      config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers;\n      config.sortOrder = 'sortOrder' in options ? options.sortOrder : 'declare';\n      config.manualOrder = 'manualOrder' in options ? options.manualOrder : [];\n      config.transform = options.transform;\n\n      if (typeof config.manualOrder === 'string') {\n        config.manualOrder = $.csv.toArray(config.manualOrder, config);\n      }\n\n      if (config.transform !== undefined) {\n        var origObjects = objects;\n        objects = [];\n\n        var i;\n        for (i = 0; i < origObjects.length; i++) {\n          objects.push(config.transform.call(undefined, origObjects[i]));\n        }\n      }\n\n      var props = $.csv.helpers.collectPropertyNames(objects);\n\n      if (config.sortOrder === 'alpha') {\n        props.sort();\n      } // else {} - nothing to do for 'declare' order\n\n      if (config.manualOrder.length > 0) {\n        var propsManual = [].concat(config.manualOrder);\n        var p;\n        for (p = 0; p < props.length; p++) {\n          if (propsManual.indexOf(props[p]) < 0) {\n            propsManual.push(props[p]);\n          }\n        }\n        props = propsManual;\n      }\n\n      var o;\n      var line;\n      var output = [];\n      var propName;\n      if (config.headers) {\n        output.push(props);\n      }\n\n      for (o = 0; o < objects.length; o++) {\n        line = [];\n        for (p = 0; p < props.length; p++) {\n          propName = props[p];\n          if (propName in objects[o] && typeof objects[o][propName] !== 'function') {\n            line.push(objects[o][propName]);\n          } else {\n            line.push('');\n          }\n        }\n        output.push(line);\n      }\n\n      // push the value to a callback if one is defined\n      return $.csv.fromArrays(output, options, config.callback);\n    }\n  };\n\n  // Maintenance code to maintain backward-compatibility\n  // Will be removed in release 1.0\n  $.csvEntry2Array = $.csv.toArray;\n  $.csv2Array = $.csv.toArrays;\n  $.csv2Dictionary = $.csv.toObjects;\n\n  // CommonJS module is defined\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = $.csv;\n  }\n}).call(this);\n"]},"metadata":{},"sourceType":"script"}